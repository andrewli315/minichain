import os
import json
import traceback
from CryptoUtil import CryptoUtil
from transaction import Transaction
import threading
class minichain:
    """
        block header format is ""
        version, prev_block, merkle_root, target, nonce
    """
    def __init__(self, target):
        self.DIR = './blocks'
        self.mutex = threading.Lock()
        if not os.path.isdir(self.DIR):
            os.makedirs(self.DIR,mode=0o777)
        self.target = target
        # genesis block is generated by nodes
        self.index = -1
        self.current_hash = '0'*64
        self.beneficiary = ''
        self.prev_hash = '0'*64
        self.tx_hash = '0000000000000000000000000000000000000000000000000000000000000000'        
        self.version = 2
        self.beneficiary = ''
        self.nonce = '00000000'
        self.block_hash_pool = set()

    def tx_is_exist(self, tx_sig):
        height, block_hash = self.findMaxFork()
        ret = False
        for i in range(0, height ):
            file_name = self.DIR + '/' + block_hash + '.json'
            with open(file_name,'r') as data:
                block = json.load(data)
            if block['transactions'] is not None:
                for tx in block['transactions']:  
                    if tx['signature'] == tx_sig:
                        ret = True
                        return ret
            block_hash = block['prev_block']
            if block_hash == '0000000000000000000000000000000000000000000000000000000000000000':
                break
        return ret
    def findMaxFork(self):
        max_height = -1
        fork_hash = '0'*64
        with self.mutex:
            for block_hash in self.block_hash_pool:
                file_name = self.DIR + '/' + block_hash + '.json'
                with open(file_name, 'r') as data:
                    block = json.load(data)
                if max_height < block['height']:
                    max_height = block['height']
                    fork_hash = block_hash        
        self.current_hash = fork_hash
        self.index = max_height
        return max_height,fork_hash
    """
        when confirmation >= 3, the block could be 
        regarded as credible and immutable.
        Therefore we count the balance only if the 
        confirmation of transaction is >= 3
    """
    def getAllBalance(self):
        height, block_hash = self.findMaxFork()
        balance = {}        
        confirmation = 1
        sig_pool = set()
        address_pool = set()
        for i in range(0,height):
            file_name = self.DIR + '/' + block_hash + '.json'
            with open(file_name,'r') as data:
                block = json.load(data)
            if confirmation >= 3:
                beneficiary = block['beneficiary']
                if beneficiary in address_pool:
                    balance[beneficiary] += 1000
                else:
                    balance[beneficiary] = 0
                    address_pool.add(beneficiary)
                txs = block['transactions']
                if txs is not None:
                    for tx in txs:
                        transaction = Transaction(tx)
                        pub_key = transaction.getPubKey()
                        sig = transaction.getSig()
                        signData = transaction.getSignData()
                        ret = CryptoUtil.verify(CryptoUtil, pub_key, sig, signData)
                        if ret and not sig in sig_pool:
                            sig_pool.add(sig)
                            balance[beneficiary] += tx['fee']
                            if pub_key in address_pool:
                                balance[pub_key] -= (tx['value'] + tx['fee'])
                            if tx['to'] in address_pool:
                                balance[tx['to']] += tx['value']
                            else:
                                balance[tx['to']] = 0
                                address_pool.add(tx['to'])
                                balance[tx['to']] += tx['value']
                            
            confirmation += 1
            block_hash = block['prev_block']
            if block_hash == '0000000000000000000000000000000000000000000000000000000000000000':
                break
        return balance
    # for insert the latest block
    def getBalanceOf(self, address):
        balance = self.getAllBalance()
        if address in balance:
            return balance[address]
        else:
            return 0

    # for insert the latest block
    def getBlockJson(self,block_hash):
        file_name = self.DIR + '/' + block_hash + '.json'
        with open(file_name, 'r') as data:
            block = json.load(data)
            ret = {
                    "version" : block['version'],
                    "prev_block" : block['prev_block'],
                    "transactions_hash" : block['transactions_hash'],
                    "beneficiary" : block['beneficiary'],
                    "target" : block['target'],
                    "nonce" : block['nonce'],
                    "transactions": block['transactions']
                    }
            return json.dumps(ret)

    def insertBlock(self, height,prev_hash,tx_hash,beneficiary, target, nonce, txs, block_hash):
        if txs:
            valid_txs = []
            for tx in txs:
                valid_txs.append(json.loads(tx))
        else:
            valid_txs = []
        try:
            if self.current_hash == prev_hash or self.index < height :
                self.index = height
                self.current_hash = block_hash
                # construct block header
                self.prev_hash = prev_hash
                self.tx_hash = tx_hash            
                self.target = target
                self.nonce = nonce
                self.beneficiary = beneficiary 
            block = {
                        "version" : self.version,
                        "height" : height,
                        "prev_block" : prev_hash,
                        "transactions_hash" : tx_hash,
                        "beneficiary" : beneficiary,
                        "target" : target,
                        "nonce" : nonce,
                        "transactions" : valid_txs
                    }
            with self.mutex:
                self.block_hash_pool.add(block_hash)
                file_name = self.DIR + '/' + str(block_hash) + '.json'
                with open(file_name , 'w+') as f:
                    f.write(json.dumps(block))
                    f.flush()
                f.close()
        except:
            traceback.print_exc()
            print("Except")

    def getIndex(self):
        return self.index

    def getBlockHash(self):
        return self.current_hash

    def getDifficult(self):
        return self.target

    def getPrevHash(self):
        return self.prev_hash

    def getVersion(self):
        return self.version

    def getTxHash(self):
        return self.tx_hash

    def getTarget(self):
        return self.target
